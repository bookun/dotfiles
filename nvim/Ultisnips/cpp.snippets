snippet base "base"
#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (n); i++)
using namespace std;
typedef long long ll;
typedef pair<ll, ll> P;

ll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}
ll lcm(ll a, ll b) { return b/gcd(a,b)*b;}

int main() {
	ll n;
	cin >> n;
	vector<ll> a(n);
	rep(i, n) cin >> a[i];
	return 0;
}
endsnippet

snippet erast "bool is_prime(int x){.."
bool is_prime(int x) {
	if (x <= 1) {
		return false;
	}
	for (int i=2; i*i < x; i++) {
		if (x%i == 0) {
			return false;
		}
	}
	return true;
}
endsnippet

snippet gcd "unsigned gcd(unsigned a, unsigned b) {.."
unsigned gcd(unsigned a, unsigned b) {
	if(a < b) return gcd(b, a);
	unsigned r;
	while ((r=a%b)) {
		a = b;
		b = r;
	}
	return b;
}
endsnippet

snippet P! "next_permutation()"
vector<ll> tmp = {1, 2, 3}
do {
	//already sorted
	// 0: {1, 2, 3}
	// 1: {1, 3, 2} 
	// ....
} while (next_permutation(tmp.begin(), tmp.end()));
endsnippet

snippet cout "cout << $1 << endl"
cout << $1 << endl;
endsnippet

snippet sort "sort"
sort(h.begin(), h.end(), greater<ll>());
endsnippet

snippet bfs "bfs with variables"
#define MAX_N 100
#define MAX_M 100
vector<vector<char>> maze(MAX_N, vector<char>(MAX_M + 1));
int sx, sy; // start point
int gx, gy; // goal point
int n, m; //問題の行列
int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
const int INF = 100000;
char wall_char = '#';
// 最短距離保存テーブル
vector<vector<int>> d(MAX_N, vector<int>(MAX_M, INF));
int dfs() {
  queue<P> que;
  que.push(P(sx, sy));
  d[sx][sy] = 0;

  while(que.size()) {
    P p = que.front(); que.pop();
    if (p.first == gx && p.second == gy) break;

    rep(i, 4) {
      int nx = p.first + dx[i], ny = p.second + dy[i];

      if (0 < nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != wall_char && d[nx][ny] == INF) {
        que.push(P(nx, ny));
        d[nx][ny] = d[p.first][p.second] + 1;
        printf("d[%d][%d] = %d\n", nx, ny, d[nx][ny]);
      }
    }
    //if (que.size() > 1) {
    //  rep(i, que.size()) {
    //    P hoge = que.front(); que.pop();
    //    cout << hoge.first << " " << hoge.second << endl;
    //  }
    //  return 0;
    //}
  }
  return d[gx][gy];
}
endsnippet

snippet dfs "dfs with variables"
#define MAX_N 100
#define MAX_M 100
int n, m;
char wall_char = 'W';
vector<vector<char>> field(MAX_N, vector<char>(MAX_M));
void dfs(int x, int y) {
  field[x][y] = '.';

  for (int dx = -1; dx <= 1; dx++) {
    for (int dy = -1; dy <= 1; dy++) {
      int nx = x + dx, ny = y + dy;
      if (0 <= nx && nx < n && 0 <= ny && ny < m && field[nx][ny] == wall_char) dfs(nx, ny);
    }
  }
}
endsnippet
